### Задача 1: API Gateway

Для реализации API Gateway в микросервисной архитектуре необходимо выбрать решение, которое обеспечивает маршрутизацию запросов, проверку аутентификации и терминацию HTTPS. Рассмотрим несколько популярных решений, сравнив их по ключевым параметрам.

| Решение          | Маршрутизация запросов | Проверка аутентификации | Терминация HTTPS | Масштабируемость | Поддержка плагинов | Легкость настройки |
|------------------|------------------------|-------------------------|------------------|------------------|--------------------|--------------------|
| **Kong**         | Да                     | Да                      | Да               | Высокая           | Да                 | Средняя            |
| **NGINX**        | Да                     | Ограниченная            | Да               | Высокая           | Ограниченная       | Высокая            |
| **Traefik**      | Да                     | Да                      | Да               | Высокая           | Да                 | Высокая            |
| **AWS API Gateway** | Да                 | Да                      | Да               | Высокая           | Ограниченная       | Высокая            |

**Обоснование выбора:**  
На основе сравнительной таблицы, наиболее подходящим решением является **Traefik**. Он обладает всеми необходимыми функциями, включая маршрутизацию, проверку аутентификации и терминацию HTTPS, при этом прост в настройке и поддерживает широкую интеграцию через плагины. Traefik также хорошо масштабируется, что важно для крупных систем с микросервисной архитектурой. В отличие от NGINX, Traefik изначально разрабатывался как решение для микросервисов, что делает его наиболее естественным выбором для современных проектов.

### Задача 2: Брокер сообщений

Для выбора брокера сообщений, который будет использоваться в микросервисной архитектуре, необходимо учитывать надежность, скорость, поддержку кластеризации и других важных функций. Сравним несколько брокеров сообщений по ключевым параметрам.

| Брокер          | Кластеризация | Хранение сообщений на диске | Скорость работы | Поддержка форматов сообщений | Разделение прав доступа | Простота эксплуатации |
|-----------------|---------------|----------------------------|----------------|-----------------------------|-------------------------|-----------------------|
| **RabbitMQ**    | Да            | Да                         | Высокая        | AMQP, MQTT, STOMP            | Да                      | Средняя               |
| **Kafka**       | Да            | Да                         | Очень высокая  | Avro, JSON, Protobuf         | Да                      | Низкая                |
| **ActiveMQ**    | Да            | Да                         | Средняя       | AMQP, MQTT, OpenWire         | Да                      | Высокая               |
| **Redis Streams** | Ограниченная | Да                         | Высокая        | JSON, Protobuf               | Ограниченная            | Высокая               |

**Обоснование выбора:**  
На основе сравнительной таблицы наиболее подходящим решением является **RabbitMQ**. Он поддерживает кластеризацию, что обеспечивает высокую надежность, и хранение сообщений на диске, что гарантирует сохранность данных. RabbitMQ также поддерживает несколько форматов сообщений и обладает хорошим разделением прав доступа. Несмотря на то, что Kafka превосходит RabbitMQ по скорости, RabbitMQ легче в эксплуатации и лучше поддерживает различные протоколы. Это делает его более универсальным и удобным для большинства сценариев использования в микросервисной архитектуре.